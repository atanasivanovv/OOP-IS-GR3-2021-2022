## Упражнение #1

<br>

### Структури

Mасивитe ни позволяваха да съхраняваме елементи от един и същи тип в последователна наредба. Например масив от цели числа, символи и тн. В реалния живот се налага да работим с елементи от различни типове. Тогава се намесват структурите. Структурите са типове данни дефинирани от потребителя, които ни позволяват да групираме елементи от различни типове и да ги съхраняваме.

```c++
struct <name of structure>
{
  <member definition>;  //  int arr[5];
  <member definition>;  //  int age;
  <member definition>;  //  double weight; 
        ...
  <member definition>;
  
}<one or more variables of <name> type>;

/*---------- Example ----------*/

struct Student
{
  char name[20];
  char faculty_number[5];
  unsigned int age;

};
 
```

### **Дефиниране на променливи от тип структура**
За структурата в паметта не се отделя памет. Паметта се отделя чак когато създадем обект от тип структура. Както при обикновените типове и тук дефинирането на променливи и константи от даден потребителски тип(структура) става чрез името на типа и името на променливата след това.

```c++
<
}name of structure> <variable_name>;

/*---------- Example ----------*/

Student student_one;

```

### **Разлика между обект и структура.**  
Структурата има за цел да обобщи и да дефинира как ще се държи даден обект от реалния свят. Чрез структурата създаваме различни видове обекти, които се обобщават в дадена структура. 

*Например* Ако имаме структурата Car променливите, които създаваме от тип Car са обекти.

Car volvo; Car golf; Car jigula са обекти. 

### **Достъп до елементите(членовете) на структурата**
Достъпът до, който и да е, елемент на структурата се осъществява чрез оператора(.). Като използваме следния синтаксис:

```c++
<name of object>.<member_name>;

/*---------- Example ----------*/

cout << student_one.name << endl;
```

### **Функции със структури**
За структурите е характерно, че променливите от тип структура могат да се инициализират със стойности на вече дефинирана променлива от същия тип. 

```c++

Student student_one;
Student student_two = student_two;

```
Но за да работим със структурите ефективно трябва да дефинираме и други функции, като например функция:
* за инициализиране на елементите на структурата
* за извеждане на елементите на структурата на екрана
* за променяне стойностите на елементите на структурата

## Enums

------------ dsa

## Динамична памет

[www.tutorialspoint.com/cplusplus/cpp_dynamic_memory](https://www.tutorialspoint.com/cplusplus/cpp_dynamic_memory.htm)  

### За разлика от повечето езици за програмиране, С++ добавя още малко интересни неща свързани с директния достъп до паметта (освен указателите). В C++ паметта, с която вашата програма работи се разделя на **2 части:**

* **Stack** - паметта, която се заделя и освобождава автоматично за всички променливи във всички функции на програмата + стековите рамки на функциите.
* **Heap** - паметта, която не се изпозва от програмата, докато ние **РЪЧНО** не я заделим и освободим, по време на изпълнението на програмата.

[Stack & Heap](https://www.geeksforgeeks.org/memory-layout-of-c-program/)

## **Важно!** 

### При динамично заделената памет, програмистът отговаря за нейното заделяне(когато му е необходима) и освобождаване(когато вече не му е неонходима). Ако не освободи паметта, ще се получи MEMORY LEAK - изтичане на памет (последвано обикновено от СИН екран на смъртта).

## Заделяне и освобождаване на динамична памет
### С++ поддържа два оператора за манипулиране на динамичната памет: **new** - за заделяне и **delete** - за освобождаване. 

### **NEW**
```c++
pointer-variable = new data-type;

int *ptr = new int(25);

int *ptr2 = new int[10];
```
### **Ако няма достатъчно памет, която искаме да заделим, тогава се връща "грешка" от тип std::bad_alloc или NULL указател.**

### **DELETE**
```c++
delete pointer-variable; 

delete ptr;

delete[] ptr2;
```
### **Не забравяйте []! иначе няма да освободи и 10-те клетки.**